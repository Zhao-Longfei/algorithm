# 贪心算法
## 跳跃游戏II
## leetcode 45 ，medium

给定一个非负整数数组，你最初位于数组的第一个位置。

数组中的每个元素代表你在该位置可以跳跃的最大长度。

你的目标是使用最少的跳跃次数到达数组的最后一个位置。

假设你总是可以到达数组的最后一个位置。


### 示例 1:
```
输入: [2,3,1,1,4]
输出: 2
解释: 跳到最后一个位置的最小跳跃数是 2。
     从下标为 0 跳到下标为 1 的位置，跳 1 步，然后跳 3 步到达数组的最后一个位置。
```
### 示例 2:
```
输入: [2,3,0,1,4]
输出: 2
```

### 提示:
```
1 <= nums.length <= 1000
0 <= nums[i] <= 10^5
```

以实例1为例子：

分析：

起始位置为第一个数，所以到第一个数的步数需要`0`步

暂时创建一个容器用来保存步数，`step[0] = 0`: 代表到达位置`0` 需要0步

因为`nums[i]`代表的是跳跃长度，所以从位置`0`可以跳跃`nums[0]=2`步

所以位置`0`的跳跃区间为`[0,2]`,这里把右区间记为`r`，所以r从0变成了2

所以`step[1]=1,step[2]=1`,代表到达位置1都和2都只需要一步，

那么下一步有两个选择，一个是跳跃一步到达位置1，一个是跳跃两步到达位置2：

<br>


1.与位置0类似，我们尝试从位置1往后跳，因为`num[1]=1`，此时最右端还是位置2，右区间没有增加.所以我们不做记录，因为从位置0都可以到达位置2，没有必要多走一步到达位置2

<br>

2.从位置2往后跳，因为`nums[2]=3`,此时最右端达到了4，右区间增加了，所以类似的：
`step[3]=2,step[4]=2`,代表到达位置3和4都只需要两步

重复此过程知道右边界等于整个数组的大小

代码：
```
class Solution {
public:
    int jump(vector<int>& nums) {
        int n=nums.size();
        vector<int> step(n,0);
        int r=0;
        for(int i=0;i!=n;++i){
            int nr = min(nums[i]+i,n-1);
            if(nr<r){
                continue;
            }
            else{
                for(int j = r+1;j<=nr;++j){
                    step[j] = step[i]+1;
                }
            r = nr;
            }
        }
        return step[n-1];
    }
};
```







